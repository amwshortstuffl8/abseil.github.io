---
title: "Tip of the Week #137: Avoid Public Aliases"
layout: tips
sidenav: side-nav-tips.html
published: false
permalink: tips/137
type: markdown
order: "137"
---

Originally posted as TotW #137 on August 25, 2017

*by George Karagoulis , [(karagog@google.com)](mailto:karagog@google.com)*

*"Although Smith, Jones, and Johnson are easy names to remember when there is no
occasion to remember them, it is next to impossible to recollect them when they
are wanted. How do criminals manage to keep a brand-new alias in mind? This is a
great mystery." - Mark Twain, Life on the Mississippi*

Have you ever gotten sick of typing long type names over and over? Wouldn't it
be easier just to define an alias in your public API that saves you time from
repetitive typing? For example, consider the following alias:

```c++
// Bad code
//
// In foo.h:
using Foos = std::vector<Foo>;
void Set(const Foos& foos);
```

This week's tip is to convince you that making trivial aliases part of your
public API is misguided, and codebases which make heavy use of public aliases
are harder to maintain.

## The Hidden Cost of Typing Less

While the text may be easier to read because it's shorter, it hides important
details from the reader, which must be learnt and remembered while reading the
code. For example, `Foos` above could just as easily be an alias for a
`std::list`, `std::set`, etc..., all of which have similar APIs, but also have
key differences that might be important to the reader. For example, is there a
`push_back()` method? How many arguments does `insert()` take? Outside the local
context where the alias is declared, it is harder to use because it raises more
questions than it answers. Consider the following function signature one might
encounter in an alias-heavy API:

```c++
// Bad code
void PushFront(FooPtr foo, FooPtrs* foo_ptrs);
```

This function raises several questions. First, is `FooPtr` a raw pointer or is
it a `std::unique_ptr` (i.e. is ownership of the pointer transferred?) Second,
what kind of container is `FooPtrs`? Since the method is called `PushFront()` I
might assume it is a `std::list`, `std::forward_list` or `std::deque`, all of
which implement a `push_front()` method. All of these questions could be
answered immediately by inspection if you simply elide the alias. See how
unambiguous the signature is now:

```c++
// Good code
void PushFront(std::unique_ptr<Foo> foo,
               std::vector<std::unique_ptr<Foo>>* foo_ptrs);
```

Surprise! It turns out that the container was a `std::vector` all along. But you
can't be blamed for guessing wrong, because that's a fundamental problem with
defining trivial aliases. By obscuring common types with aliases, you are
forcing the reader to continually check what the aliases mean, until they
eventually memorize all of them (or simply remove them out of frustration). In
these trivial cases, aliases only serve to add cognitive load that makes our job
slower and more difficult as software engineers.

## The Illusion of More Flexibility

What if I want to write container-independent code, so callers don't need to
know or care what the underlying types are? The problem is that in practice such
flexibility is rarely needed, and is also difficult to attain (see Scott Meyers'
Effective STL Item 2, "Beware the illusion of container-independent code").
While it may be possible *in some cases* to substitute a `std::deque` in place
of a `std::vector` without changing the calling code, if you instead wanted to
substitute a `std::set`, you'd still have to inspect all the callsites to
make sure the change makes sense semantically. [Hyrum's Law](http://hyrumslaw.com)
states that you probably *can't* change a type trivially after others start
using it. Unless you're actively trying to refactor specific type to another
specific type in a large codebase, you're probably not going to need (or want)
this level of flexibility.

## So When are Aliases OK?

The [Google C++ styleguide](https://google.github.io/styleguide/cppguide.html#Aliases)
spells out the specific guidelines for when and how public
aliases can be used at, and is authoritative on the subject.
In particular, the style guide allows public aliases when providing a useful
abstraction for your class, but where defining a completely new type is
overkill.

For example:

```c++
// Used to store field measurements. DataPoint may change from Bar* to some
// internal type. Client code should treat it as an opaque pointer.
using DataPoint = foo::Bar*;
```

Another allowed use is for heavily templated types, although if the type is
complex enough you might also consider making a dedicated class for it. (See
[TotW #115](/tips/115) for alternatives to aliases that may be better suited.)

For example:

```c++
// A set of measurements. Just an alias for user convenience.
using TimeSeries =
    std::unordered_set<DataPoint, std::hash<DataPoint>, DataPointComparator>;
```

So where to draw the line? The best we can do is give rules of thumb and trust
your judgement. Niche use cases, such as refactoring across a large codebase,
may require public aliases, but otherwise they should generally be avoided.

Note that this TotW is primarily about public aliases, so these rules can be
relaxed for non-public aliases which are merely implementation details (e.g. in
a .cc file or in the private section of a class definition). Within a local
scope it's easier to see and remember this shorthand; reducing line length and
token count can indeed improve readability when used judiciously. Just because
an alias is in a .cc file doesn't necessarily mean it's okay to define
trivial aliases like `Foos`, but this is left as a judgement call for the
engineer.

# In Conclusion

Think hard the next time you're tempted to add a type alias to your public API,
and please keep in mind the styleguide rules. When considering a public alias
intended solely for convenience, your default action should be to avoid it.
