---
title: "Tip of the Week #81: A Type by Another Name"
layout: tips
sidenav: side-nav-tips.html
published: false
permalink: tips/81
type: markdown
order: "081"
---

Originally posted as TotW #81 on August 29, 2014

*by Greg Miller, [(jgm@google.com)](mailto:jgm@google.com)*

*"A rose by any other name would smell as sweet" â€” Juliet*

A type alias is a name that refers to a previously declared type. It does not
define a new type; it simply defines a new name. An alias is equivalent to, and
can be used anywhere in place of, the original type name.

In C and C++ we have historically used the `typedef` keyword to create type
aliases. But in C++11 the `using` keyword can be used to create simple aliases
that are equivalent to `typedef` declarations. Let us look at some examples
to see how their syntax differs.

```c++
typedef int64 DocId;                         // Equivalent to ...
using DocId = int64;

typedef int (*F)(int, double);               // Equivalent to ...
using F = int (*)(int, double);

typedef std::map<std::string, std::string> StringMap;  // Equivalent to ...
using StringMap = std::map<std::string, std::string>;
```

The examples above show that the `using` aliases all have a consistent form
where the new name appears on the left-hand side of an equals sign with the
existing type on the right-hand side. This syntax is not only internally
consistent, but is also consistent with the form and semantic of assignment in
other contexts (e.g., `int b = a`). In the second example, whereas the `typedef`
buries the name of the function ("`F`") in the middle of the syntax, the using
form places the new name clearly on the left-hand side of the equals sign.

Type aliases with `using` surpass `typedef` in more than just syntax. Their
ability to create alias templates that refer to a family of types is new
functionality that is not available with `typedef`. The following example
creates an alias template that expands to a map of `std::string` to T:

```c++
template <typename T>
using StringMap = std::map<std::string, T>;

StringMap<int> sm;
sm["hello"] = 42;
```

Type aliases created with `using` in C++11 have advantages in their consistent
syntactic form and their ability to be used within templates. Of course,
`typedef` has the advantage of being more common in legacy code and it's not
going away anytime soon. So as you write your C++11 code going forward, consider
which type alias form you want to use.
