---
title: "Tip of the Week #115: Wrappers and Type Aliases"
layout: tips
sidenav: side-nav-tips.html
published: false
permalink: tips/115
type: markdown
order: "115"
---

Originally posted as TotW #115 on April 28, 2016

*by Eric Burnett , [(ericburnett@google.com)](mailto:ericburnett@google.com)*

*"A weed is no more than a flower in disguise, \
Which is seen through at once, if love give a man eyes." — James Russell Lowell*

We often find ourselves using values that have semantics beyond what's expressed
by their underlying data type. In C++ we have a number of ways of working with
such values, ranging from giving variables a clear name to crafting custom
classes to wrap the storage of said values in APIs we control.

Despite their robustness we're clearly not going to write new classes for every
semantically-different value in our code, but it can be a maintenance burden –
if not outright unsafe – to simply use such storage types directly and rely on
names or comments to distinguish. So when **should** we choose one mechanism
over another? Let's look at the options.

Here are four ways you can add semantic information to your code's variables.
They range from lightweight, with relatively few benefits, to heavyweight, with
more benefits but at correspondingly higher cost.

## Names and Comments

```c++
// The number of a committed code change.
int32 change_num;
```

Noting semantics purely through names or comments is the weakest but simplest
option. Some values don't really have notable semantics to warrant a new
explicitly-defined type. Many of these typews are used as one-offs, with only
one or two variables carrying the same semantics and not worth the overhead
of doing more. And in some cases, having the underlying storage type explicitly
visible has its own benefit.

## Type Aliases

```c++
typedef int32 ChangeNumber;
using ChangeNumber = int32;
```

Type aliases fall firmly on the side of convenience over safety: they can
provide **clarity**, **searchability**, and **documentability**, but do *not*
give any encapsulation or type safety benefits. They are best reserved for use
within relatively self-contained codebases where consistency can be enforced, as
the compiler will be of no help in forcing usage or avoiding collisions. That
said, aliases can still be worthwhile: when used consistently, and when
unintended collisions are unlikely, aliases provide clarity, searchability, and
documentability with no runtime overhead and without adding any overhead for
reading or writing code. Consistently used aliases can also make it easier to
change the underlying type (e.g. `int32` to `int64`), though their lack of
encapsulation means this shouldn't be relied upon.

See also the
["Aliases" section withi the Google C++ styleguide](https://google.github.io/styleguide/cppguide.html#Aliases)
, as well as [TotW #137](/tips/137) for when *not* to add aliases to an API.

### Benefits

**Clarity**: types can help make it obvious when values are different, making it
easier to avoid unintended reinterpretations. A `MessageTemplate` and a
`LocalizedMessage` are obviously different, whereas `std::string message` could
be confused for either.

Similarly, by virtue of being known to the compiler, types enforce their own
consistent spelling. A mess like that shown below wouldn't have happened if one
type with a consistent name were used for each of these values:

```c++
int64 policy_id;
int32 policy;
int64 policy_id;
int64 policy_label_id;
int32 label_id;          // Is this even the same? Who knows!
```

**Searchability**: a named type can be more easily searched within a codebase,
letting you trace its usage, find all variables needing updating, or narrow
your search for a bug.

**Documentability**: the semantics of method arguments and return values should
be documented clearly for API callers. A type provides a common location to
document that a value has particular semantics, allowing redundant documentation
to be eliminated.

```c++
// Ok:
// Returns the canonical ID for a document that has the given name. Names
// are unique by definition amongst canonical documents, so at most one
// document may be matched. If no match is found, returns 0.
int64 LookUpDocByName(const std::string& name) const;
```

```c++
// Better:
// A canonical ID for a document. Documents may be canonicalized to give
// them a unique and stable ID and name. Notably, canonical IDs have a 1:1
// mapping with canonical doc names.
using CanonicalDocId = int64;
[... elsewhere...]
// Returns the CanonicalDocId for the given doc name if one exists, or kNoDoc
// otherwise.
CanonicalDocId LookUpDocByName(const std::string& name) const;
```

Types also allow you to document what values should be considered valid, and
what APIs they should be used with. For example, a type backed by `std::string`
may restrict valid values to those returned by a specific function or having a
given prefix.

## Type-safe Wrappers

```c++
DEFINE_HANDLE_TYPE(ChangeNumber, int32);  
DEFINE_STRONG_INT_TYPE(ChangeNumber, int32);
struct ChangeNumber {
  int32 value;
};
// Proto
message ChangeNumber {
  optional int32 value = 1;
}
```

Type-safe wrappers are often a good middle ground, offering many of the benefits
of full classes, at low cost. Notably, a type-safe wrapper is *not* going to
provide encapsulation, and any functions you wish to provide need to be done
outside the class, but these wrappers will otherwise still net you **type
safety** on top of the other benefits listed above.

For other non-integral values simple one-member structs can serve the same
purpose. Simple proto messages are also often used, though there are other
factors to take into account when considering protos that are not covered here.

### Benefits

All the benefits of *Type aliases*, plus:

**Type Safety**: with type-safe types you can control what implicit conversions
are allowed, and have this enforced by the compiler. If `OriginalChangeNumber`
and `SubmittedChangeNumber` are apt to be confused but aren't interchangeable,
you really want type-safe types. Equally, any values that would be high impact
to mix up – e.g. any value representing billable money – should probably be
type-safe even if you don't think a mix-up is likely.

## Full Classes

```c++
class ChangeNumber {
 ...
 private:
  int32 change_number_;
};
```

The costs of a full wrapper class are fairly obvious, and high: they take effort
to write and maintain, and add a burden on users in the form of a new API they
have to learn when trying to do anything with your values.

Classes are often the preferred solution for widely used APIs, because on top of
everything above they provide **encapsulation**: where you explicitly want to
avoid users coming to rely on the underlying representation, or want to build
something far more powerful around the semantics. But given the cost, it should
be relatively rare to see one of these with only a few uses.

[absl::Time](https://github.com/abseil/abseil-cpp/blob/master/absl/time/time.h)
is an example of a class done right – it *could* be replaced with an `int128`,
but the codebase would be much worse off for it.

### Benefits

All the benefits of *Type aliases* and *Type-safe wrappers*, plus:

**Encapsulation**: a class you control can separate the semantic value from its
underlying representation, making it possible to change the storage type without
impacting any code using the class.

In addition, you can define operations on a class that make sense for it but
don't make sense generically – think of the difference between a `Vector3`
(google3/util/math/vector.h) and an array with three members.

## Recommendations

Regardless of mechanism, defining a type can do more harm than good if it's not
consistently used: you lose most of the benefits, but keep most of the costs.

One implication of this caveat is that types should be defined as centrally as
possible. In our `ChangeNumber` example, you'd expect to see it defined only
once throughout the codebase.

Another important consideration to defining types is that they should actually
have independently interesting semantics. A `VideoDuration` is likely not a good
type, since it's not really any more than a `Duration` – though it could be if
there were some additional constraints to enforce and rely on like 'videos must
have durations in increments of 5s'.

Otherwise,

-   Values without notable semantics shouldn't get newly defined types.
-   If users need to understand the underlying storage type anyway, avoid fully
    encapsulated types, and possibly any form of explicit type at all.
-   For values used within a single cc file, define an explicit type if it's
    more readable or if you want one for type safety.
-   For widely used APIs, use a class with encapsulation if you want the
    flexibility to change the underlying storage type later.
-   For types that warrant an API of their own, prefer using an encapsulated
    class.
-   For types you don't control all usages of, prefer type-safe types over
    aliases for enforced consistency.
-   For types with values likely to get mixed up, or especially impactful if
    they were, prefer type-safe types without implicit casting.
