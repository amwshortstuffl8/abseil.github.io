---
title: "Tip of the Week #98: User-defined Flag Types and absl::Duration"
layout: tips
sidenav: side-nav-tips.html
published: true
permalink: tips/98
type: markdown
order: "098"
---

*by [Bradley White](mailto:bww@google.com)*

NOTE: this tip contrasts legacy flags (of the form `DEFINE_flagname`)
with new-style Abseil flags of the form `ABSL_FLAG()`. The legacy forms
are now deprecated; as a result, some of this tip is historical in
nature, but the advice on using custom flags is current.)

*"Do you have a flag?" - Eddie Izzard.*

## Flags of User-Defined Types

The Abseil Flags library now supports flags of user-defined types.

Previously a flag had to be one of the the fundamental types: `bool`,
`int32_t`, `int64_t`, `uint64_t`, `double`, `std::string`, where a flag
definition like ...

```c++
DEFINE_string(default_host, "www.google.com", "For requests with no host");
```

expands directly into the definition of a global variable: `FLAGS_default_host`,
of type `std::string`, with a default value of `"www.google.com"` and the given
description. These flags are deprecated and people should now prefer the
`ABSL_FLAG()` definition.

Now with the Abseil Flags library, a flag can be of any type whose value can
be parsed from text given on the command line.

For example, if you wanted a flag to represent a value of `YourType`:

```c++
ABSL_FLAG(YourType, your_flag, default_value, description);
```

expands into the definition of a `absl::Flag<YourType>` object.

```c++
absl::Flag<YourType> FLAGS_your_flag = ...;
```

The flag can then be read or written using a couple of helper functions.

```c++
YourType v = absl::GetFlag(FLAGS_your_flag);
...
absl::SetFlag(&FLAGS_your_flag, v);
```

See
[Defining Custom Flag Types](/third_party/absl/g3doc/docs/guides/flags.md#custom)
for details on how to adapt your type to the requirements of `ABSL_FLAG()`. In
particular, you'll need to define parsing (`std::string` -> `YourType`) and
unparsing (`YourType` -> `std::string`) functions by providing overloads of
`AbslParseFlag()` and `AbslUnparseFlag()`.

Note that you should **only adapt types that you own**. (*Hint*: You don't own a
template instantiation like `std::vector<YourType>`, or an alias/typedef for
another type.) The type definition and its support for flags belong in the
same file. If you didn't write the class into which you're adding flag support,
ask the owners on whether you're doing it appropriately.

Built-in support for these Abseil flags exists for the same set of types
supported by direct-access flags. So, instead of the previous definition for
flag `default_host` you can now say:

```c++
ABSL_FLAG(std::string, default_host, "www.google.com",
          "For requests with no host");
```

Note that you would also need to update all legacy references to
`FLAGS_default_host` to use the helper accessors.

#### Flags and Thread Safety

One significant advantage of Abseil flags over their legacy equivalents is
that the `absl::GetFlag()` and `absl::SetFlag()` helper functions guarantee
that all accesses to the flag are thread safe.

For example, given two flag definitions:

```c++
DEFINE_string(flag_old, "default-old", "A direct-access string");
ABSL_FLAG(std::string, flag_new, "default-new", "A new-style string");
```

multiple threads can read/write the new-style `FLAGS_flag_new` without the
need for external synchronization. (`absl::GetFlag()` for integer types uses
atomic ops and so costs just a nanosecond or two. `absl::GetFlag()` on other
types acquires a `Mutex` so may cost ~10-20 nanoseconds.)

In contrast, reading the legacy `FLAGS_flag_old` while it is being updated
from another thread results in undefined behavior.

## Flags for Durations of Time

Consider the flag:

```c++
DEFINE_int64(foo_timeout_sec, 60, "How long to wait for foo to complete.");
```

Within Google, we had over 10,000 flags similar to `FLAGS_foo_timeout_sec`
that encoded some form of **duration** as an integer. The unit of duration
was typically (but not always) encoded in the flag-name suffix string.
For example, `_us`, `_ms`, `_sec`, etc.

Such flags have often been the source of error when there is confusion between
users about the units. The introduction of `absl::Duration` in the
[Abseil Time library](https://github.com/abseil/abseil-cpp/tree/master/absl/time)
has eliminated the possibility of such confusion in normal code. Support for
user-defined types for flags now allows us to do the same thing for duration
values specified on the command line. Indeed, `absl::Duration` has already been
adapted.

A safer replacement for `FLAGS_foo_timeout_sec` would be:

```c++
ABSL_FLAG(absl::Duration, foo_timeout, absl::Seconds(60),
          "How long to wait for foo to complete.");
```

Now all manipulation of `FLAGS_foo_timeout` happens through unit-safe operations
on `absl::Duration`, and the `_sec` suffix is no longer needed (or desirable).

```c++
absl::Duration timeout = absl::GetFlag(FLAGS_foo_timeout);
...
absl::SetFlag(&FLAGS_foo_timeout, absl::Milliseconds(500));
```

The command-line value can be specified using any format supported by
[`absl::ParseDuration()`][parse-duration].

For example:

```c++
$ my_app ... --foo_timeout=2m30s ...
```

## Conclusion

Consider using a flag of a user-defined type in cases where it is a clear gain
in readability and safety.

Flags specifying durations are an excellent example of where such a change would
be beneficial, and `ABSL_FLAG(absl::Duration, ...)` is already available for
your use. Remove legacy uses of ambiguous duration flags and the possibility of
error by migrating your own duration flags to the new style.

[parse-duration]: https://github.com/abseil/abseil-cpp/blob/bf29470384a101b307873b26d358433138c857fc/absl/time/time.h#L527